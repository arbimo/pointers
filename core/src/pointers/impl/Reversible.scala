package pointers.impl
import pointers._

final class Reversible extends Mem with ReversibleMem {

  private var impl = new Array[Int](32)
  private var top  = 0

  // note: 0 is not really a backtrack point but is used as a sentinel value
  // a new backtrack point is generated by decreasing the last one by 1
  // thus, backtrack points are all strictly negative and a simple sign check can differentiate them from addresses
  private var lastBackTrackPoint: BacktrackPoint = 0.asInstanceOf[BacktrackPoint]
  private var history                            = new Array[Int](16)
  private var historyTop: Int                    = 0

  private def histAdd(code: Int, value: Int): Unit = {
    if(history.length < historyTop + 2) {
      history = java.util.Arrays.copyOf(history, history.length * 2)
    }
    history(historyTop) = code
    history(historyTop + 1) = value
    historyTop += 2
  }
  private def restoreLastWrite(): Int = {
    // pop last tuple (code, value)
    val code  = history(historyTop - 2)
    val value = history(historyTop - 1)
    historyTop -= 2

    if(code >= 0) { // code represents an address and value is the value to restore
      impl(code) = value
    } else if(code == Int.MinValue) {
      assert(value > 0)
      // MinValue represents an allocation of size `value`
      // reset unused memory to 0
      var i = 1
      while(i <= value) {
        impl(top - i) = 0
        i += 1
      }
      top -= value
    } else {
      assert(value == 0)
      // `code` is a backtrack point
    }
    code
  }

  override def save(): BacktrackPoint = {
    lastBackTrackPoint = (lastBackTrackPoint - 1).asInstanceOf[BacktrackPoint] // backtrack point go towards -oo
    histAdd(lastBackTrackPoint, 0)
    lastBackTrackPoint
  }
  override def restoreLast(): Unit = restore(lastBackTrackPoint)
  override def restore(bt: BacktrackPoint): Unit = {
    require(bt <= lastBackTrackPoint)
    var x = 0
    while(x != bt) {
      x = restoreLastWrite()
    }
    lastBackTrackPoint = (bt + 1).asInstanceOf[BacktrackPoint]
  }

  override protected def read32(address: Int): Int = impl(address)

  override protected def write32(address: Int, value: Int): Unit = {
    if(lastBackTrackPoint != 0) {
      // we have a history to maintain, write current value to history
      histAdd(address, read32(address))
    }
    impl(address) = value
  }

  override protected def allocMem(size: Int): Int = {
    if(top + size < impl.length) {
      impl = java.util.Arrays.copyOf(impl, math.max(impl.length * 2, top + size))
    }
    if(lastBackTrackPoint != 0) {
      // history to maintain, record allocation in history
      histAdd(Int.MinValue, size)
    }
    val ptr = top
    top += size
    ptr
  }

}
